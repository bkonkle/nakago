# Dependency Injection

Dependency injection is a way to [decouple](https://en.wikipedia.org/wiki/Loose_coupling) your structures from their dependencies. It allows you to replace the components that your system needs with alternative implementations for different situations.

For example, a Controller may want to interact with a Repository to access information in persistent storage. In different situations you may want a Postgres Repository, a DynamoDB Repository, or an In-Memory Repository. Using dependency injection for loose coupling allows your Controller to depend on a common Repository trait that they all implement, without caring which underlying implementation actually fulfills the requirement.

This is accomplished using [any](https://doc.rust-lang.org/std/any/index.html) from Rust's standard library, along with Boxing so that the types involved can be unsized and dynamic since they are allocated on the heap. By using dynamic typing, you can write more generic code that works with different types that implement the same trait.

## Usage

First, let's establish a hypothetical Entity and a trait that defines a method to retrieve it from persistent storage:

```rust
use async_trait::async_trait;

struct Entity {
    id: String,
}

#[async_trait]
trait Repository: Sync + Send {
    async fn get(&self, id: &str) -> Option<Entity>;
}
```

Then a hypothetical Postgres implementation:

```rust
use sqlx::{Pool, Postgres};

struct PostgresRepository {
    pool: Pool<Postgres>
}

#[async_trait]
impl Repository for PostgresRepository {
    async fn get(&self, id: &str) -> Option<Entity> {
        // ...
    }
}
```

And an alternate DynamoDB implementation:

```rust
use aws_sdk_dynamodb::Client;

struct DynamoRepository {
    client: Client,
}

#[async_trait]
impl Repository for DynamoRepository {
    async fn get(&self, id: &str) -> Option<Entity> {
        // ...
    }
}
```

## Dependency Tags

The injection framework can work directly with the `TypeId` identifiers that are automatically generated by the [any](https://doc.rust-lang.org/std/any/index.html) package, but they often require you to pass in type parameters and repeat yourself more often and they result in debug output that can be rather verbose:

```rust
nakago::inject::container::test::entity::DynamoRepository was not found

Available:
 - std::boxed::Box<dyn nakago::inject::container::test::entity::Repository>

 - nakago::inject::container::test::entity::PostgresRepository
```

Tags carry the underlying type around with them, meaning it can be inferred by the compiler in most cases.

```rust
pub const POSTGRES_REPO: Tag<PostgresRepository> = Tag::new("PostgresEntityRepository");
pub const DYNAMO_REPO: Tag<DynamoRepository> = Tag::new("DynamoEntityRepository");
pub const REPO: Tag<Box<dyn Repository>> = Tag::new("EntityRepository");
```

Instead of providing the type explicitly like this:

```rust
let result = i.get_type::<PostgresRepository>()?;
```

Tags allow the compiler to pull the type from the Tag:

```rust
let result = i.get(&POSTGRES_REPO)?;
```

Tags have a special String value that can be used instead of the full type name. This makes it easier to understand debug output and allows multiple versions of the same type to have different names.

```rust
Tag(DynamoEntityRepository) was not found

Available:
 - Tag(EntityRepository)

 - Tag(PostgresEntityRepository)
```

## Providing Dependencies

To provide a dependency, create a Provider that implements the `inject::Provider` trait:

```rust
use async_trait::async_trait;
use nakago::inject;
use sqlx::{Pool, Postgres};

#[derive(Default)]
pub struct PostgresRepositoryProvider {}

#[async_trait]
impl inject::Provider<Box<dyn Repository>> for PostgresRepositoryProvider {
    async fn provide(&self, i: &inject::Inject) -> inject::Result<Box<dyn Repository>> {
        let pool = i.get::<Pool<Postgres>>()?;

        Ok(Box::new(PostgresRepository::new(pool.clone())))
    }
}
```

The `PostgresRepositoryProvider` struct is empty, and just exists so that we can implement the `inject::Provider<T>` trait. It uses `#[derive(Default)]` because it doesn't need to initialize any properties. It doesn't *have* to be empty, though, and can contain configuration for the provider that is passed in on initialization. For example, a Config provider might support an alternate config path

The result is wrapped in an `inject::Result` so that an `Err` can be returned to handle things like a failed `i.get()` call or a failed database connection initialization.

In this particular case since `Pool<Postgres>` is itself based on an `Arc`, and the pool is the only dependency currently carried by the hypothetical Repository, it's safe to provide it inside a Box like this (to handle the Unsized dynamic trait implementation). If your dependencies need shared ownership or locking, however, you may need to wrap them in an `Arc` or `Mutex` or other thread-safe container. In that case, the provider might look like this:

```rust
#[derive(Default)]
pub struct PostgresRepositoryProvider {}

#[async_trait]
impl inject::Provider<Arc<dyn Repository>> for PostgresRepositoryProvider {
    async fn provide(&self, i: &inject::Inject) -> inject::Result<Arc<dyn Repository>> {
        let pool = i.get::<Pool<Postgres>>()?;

        Ok(Arc::new(PostgresRepository::new(pool.clone())))
    }
}
```

You don't need to worry about using a Tag yet - that comes in the next step.

## The Inject Container

To make use of these Providers, create a dependency injection container:

```rust
let mut i = Inject::default();
```

This is defined as mutable because we will be injecting new dependencies into the internal container. This is typically done at an entry point to your application, such as a `main.go` file or within an integration test.

Now, use `i.provide(...).await` to use the Provider and associate it with a Tag:

```rust
i.provide(PostgresRepositoryProvider::default(), &REPO).await?;
```

I'll pause to point out here that if you had tried to use the `&POSTGRES_REPO` Tag here, the compiler would report an error because the `PostgresRepositoryProvider` above provides `Box<dyn Repository>`, not `PostgresRepository`.

## Invoking Dependencies

To pull dependencies out of the container, use `i.get(&TAG)?` or `i.get_type::<T>()?`. If a dependency isn't available, the container will return an `inject::Error::NotFound` result. This is often performed within an `provide` function from the `inject::Provider` trait, but it is also used often at entry points to bootstrap an application.

```rust
let repo = i.get(&TAG)?;
```

You can use `i.get_opt(&TAG)?` to receive an Option rather than a Result.

```rust
let maybe_repo = i.get_opt(&TAG);
```

If you want to manipulate a dependency in the Inject container, you can use `i.get_mut(&TAG)?`.

```rust
let mut loaders = i.get_mut(&CONFIG_LOADERS)?;

loaders.push(Box::<DatabaseConfigLoader>::default());
```

## Consuming Dependencies

In some cases, such as with Config Loaders, a dependency is intended to be used up and made unavailable afterwards.

```rust
let loaders = i.consume(&CONFIG_LOADERS).unwrap_or_default();

let loader = Loader::<C>::new(loaders);
```

In this example if any loaders have been provided for the `&CONFIG_LOADERS` tag, they are pulled out of the container and the tag is removed. If nothing has been injected for that tag, the above example gets the Default value of an empty Vec. If you try to `i.get()` or `i.consume()` the `&CONFIG_LOADERS` tag again, you will receive the `inject::Error::NotFound` Error.
