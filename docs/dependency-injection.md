# Dependency Injection

Dependency injection is a way to [decouple](https://en.wikipedia.org/wiki/Loose_coupling) your structures from their dependencies. It allows you to replace the components that your system needs with alternative implementations for different situations. For example, a Controller may want to interact with a Repository to access information in persistent storage.

For example, you may have a Postgres Repository, a DynamoDB Repository, and an In-Memory Repository for testing. Using dependency injection for loose coupling allows your Controller to depend on a common Repository trait that they all implement, without caring which underlying implementation actually fulfills the requirement.

This is accomplished using [any](https://doc.rust-lang.org/std/any/index.html) from Rust's standard library, along with Boxing so that the types involved can be unsized and dynamic since they are allocated on the heap.

## Usage

First, let's establish a hypothetical Entity and a trait that defines a method to retrieve it from persistent storage:

```rs
use async_trait::async_trait;

struct Entity {
    id: String,
}

#[async_trait]
trait Repository: Sync + Send {
    async fn get(&self, id: &str) -> Option<Entity>;
}
```

Then a hypothetical Postgres implementation:

```rs
use sqlx::{Pool, Postgres};

struct PostgresRepository {
    pool: Pool<Postgres>
}

#[async_trait]
impl Repository for PostgresRepository {
    async fn get(&self, id: &str) -> Option<Entity> {
        // ...
    }
}
```

And an alternate DynamoDB implementation:

```rs
use aws_sdk_dynamodb::Client;

struct DynamoRepository {
    client: Client,
}

#[async_trait]
impl Repository for DynamoRepository {
    async fn get(&self, id: &str) -> Option<Entity> {
        // ...
    }
}
```

### Tags

The injection framework can work directly with the `TypeId` identifiers that are automatically generated by the [any](https://doc.rust-lang.org/std/any/index.html) package, but they often require you to pass in type parameters and repeat yourself more often and they result in debug output that can be rather verbose:

```text
nakago::inject::container::test::entity::DynamoRepository was not found

Available:
 - dyn nakago::inject::container::test::entity::Repository

 - nakago::inject::container::test::entity::PostgresRepository
```

Tags carry the underlying type around with them, meaning it can be inferred by the compiler in more cases.

```rs
pub const POSTGRES_REPO: Tag<PostgresRepository> = Tag::new("PostgresEntityRepository");
pub const DYNAMO_REPO: Tag<DynamoRepository> = Tag::new("DynamoEntityRepository");
pub const REPO: Tag<dyn Repository> = Tag::new("EntityRepository");
```

This:

```rs
let result = i.get::<PostgresRepository>(&POSTGRES_REPO)?;
```

Becomes this:

```rs
let result = i.get_tag(&POSTGRES_REPO)?;
```

Tags also carry a unique String value to use in place of the fully qualified type name, making debug output more readable.

This results in much cleaner debug output:

```text
Tag(DynamoEntityRepository) was not found

Available:
 - Tag(EntityRepository)

 - Tag(PostgresEntityRepository)
```

If you use a mismatched type the compiler will complain, saving you from a likely bug:

```rs
error[E0308]: mismatched types
   --> src/my/entity.rs:216:45
    |
216 |         let result = i.get_tag::<dyn Repository>(&POSTGRES_REPO)?;
    |                        ------------------------- ^^^^^^^^^^^^ expected trait object `dyn inject::container::test::entity::Repository`, found struct `inject::container::test::entity::PostgresRepository`
    |                        |
    |                        arguments to this function are incorrect
    |
    = note: expected reference `&'static inject::tag::Tag<dyn inject::container::test::entity::Repository>`
               found reference `&inject::tag::Tag<inject::container::test::entity::PostgresRepository>`
note: associated function defined here
   --> src/inject/tag.rs:41:12
    |
41  |     pub fn get_tag<T: Any + ?Sized>(&self, tag: &'static Tag<T>) -> Result<&T, Error> {
    |            ^^^^^^^                         --------------------
```

### Providers

To provide a dependency, first create a Provider that implements the `inject::Provider` trait:

```rs
use async_trait::async_trait;
use nakago::inject;
use sqlx::{Pool, Postgres};

#[derive(Default)]
pub struct PostgresRepositoryProvider {}

#[async_trait]
impl inject::Provider<Box<dyn Repository>> for PostgresRepositoryProvider {
    async fn provide(&self, i: &inject::Inject) -> inject::Result<Box<dyn Repository>> {
        let pool = i.get::<Pool<Postgres>>()?;

        Ok(Box::new(PostgresRepository::new(pool.clone())))
    }
}
```

The PostgresRepositoryProvider struct is empty, and just exists so that we can implement the `inject::Provider<T>` trait. It uses `#[derive(Default)]` because it doesn't need to initialize any properties. It doesn't *have* to be empty, though, and can contain configuration for the provider that is passed in on initialization.

The result is wrapped in an `inject::Result` so that an `Err` can be returned to handle things like a failed `i.get()` call or a failed database connection initialization.

In this particular case, since `Pool<Postgres>` is based on an `Arc` and that is the only dependency currently carried by the hypothetical Repository, it's safe to provide it inside a Box like this (to handle the Unsized dynamic trait implementation). If your dependencies need shared ownership or locking, however, you may need to wrap them in an `Arc` or `Mutex` or other thread-safe container. In that case, the provider might look like this:

```rs
#[derive(Default)]
pub struct PostgresRepositoryProvider {}

#[async_trait]
impl inject::Provider<Arc<dyn Repository>> for PostgresRepositoryProvider {
    async fn provide(&self, i: &inject::Inject) -> inject::Result<Arc<dyn Repository>> {
        let pool = i.get::<Pool<Postgres>>()?;

        Ok(Arc::new(PostgresRepository::new(pool.clone())))
    }
}
```

You don't need to worry about using a Tag yet - that comes in the next step.

### Injection

To make use of these Providers, create a dependency injection container:

```rs
let mut i = Inject::default();
```

This is defined as mutable because we will be injecting new dependencies into the internal container. This is typically done at an entry point to your application, such as a `main.go` file or within an integration test.

Now, use `i.provide_tag(...).await` to use the Provider and associate it with a Tag:

```rs
i.provide_tag(PostgresRepositoryProvider::default(), &REPO).await?;
```

I'll pause to point out here that if you had tried to use the `&POSTGRES_REPO` Tag here, the compiler would report an error because the Provider implements `inject::Provider<dyn Repository>`.

You *can* provide multiple `inject::Provider<T>` implementations for different types using the same base struct. Be advised that there are cases where inference will fail in that case, however, and you'll have to pass the type parameter in explicitly, like this:

```rs
i.provide::<dyn Repository, _>(PostgresRepositoryProvider::default()).await?;
```

When using Tags, however, the compiler can often successfully infer which `inject::Provider<T>` implementation to select - another bonus of using them!

### Invocation

To pull dependencies out of the container, use `i.get_tag(tag)?` or `i.get::<T>(...)?`. If a dependency isn't available, the container will return an `inject::Error::NotFound` result. This is often performed within an `provide` function from the `inject::Provider` trait, but it is also used sometimes at entry points to bootstrap an application.

```rs
let repo = i.get_tag(tag)?;
```

## Coming Soon

In future updates, watch for convenience methods around managing lists of dependencies - such as HTTP request handlers or GraphQL resolvers - with a plugin-style approach for use within the broader Nakago framework.
