"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[130],{7735:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"pivot-di-toolkit","metadata":{"permalink":"/blog/pivot-di-toolkit","editUrl":"https://github.com/bkonkle/nakago/tree/main/website/blog/2024-08-28-pivot.md","source":"@site/blog/2024-08-28-pivot.md","title":"Pivot to a Dependency Injection Toolkit","description":"Nakago Pivots to a Dependency Injection Toolkit","date":"2024-08-28T00:00:00.000Z","tags":[],"readingTime":2.42,"hasTruncateMarker":false,"authors":[{"name":"Brandon Konkle","title":"Principal Engineer @ Formidable","url":"https://github.com/bkonkle","imageURL":"https://github.com/bkonkle.png","key":"bkonkle","page":null}],"frontMatter":{"slug":"pivot-di-toolkit","title":"Pivot to a Dependency Injection Toolkit","authors":["bkonkle"]},"unlisted":false,"nextItem":{"title":"Welcome","permalink":"/blog/welcome"}},"content":"## Nakago Pivots to a Dependency Injection Toolkit\\n\\nWith the release of Nakago v0.23, the project is pivoting away from the ambitious goal of a full-featured API framework, and towards a more streamlined dependency injection toolkit instead. The async Rust ecosystem is growing rapidly, and I haven\'t been able to devote enough time to Nakago to grow the application lifecycle and convenience features that I had originally envisioned. There are other projects that are doing a great job of providing these features - like [Loco](https://loco.rs/), [Tide](https://github.com/http-rs/tide), [Seaography](https://github.com/SeaQL/seaography), or [Salvo](https://salvo.rs/).\\n\\nWhat I haven\'t seen yet, however, is an async-first dependency injection container that is as lightweight and easy to work with as Nakago is, and doesn\'t require a lot of opaque macros or code generation. Nakago uses macros sparingly and takes advantage of Rust\'s `Any` dynamic typing tools to support a thread-safe, async-first dependency injection container that would work well with a variety of different Rust frameworks and team sizes.\\n\\nI\'ll continue refining Nakago and adding features and integrations as I have need of them on side projects, and I\'d love to collaborate with others who are interested in building a lightweight, async-first dependency injection toolkit for Rust.\\n\\n### The v0.23 Changelog\\n\\n### Removed\\n\\n- `nakago` - Removed `Application`, `Hooks`, the `lifecycle::EventType` and `lifecycle::Events` enums. The `config` utilities were moved to `nakago-figment`.\\n- `nakago-axum` - Removed `AxumApplication`, `Route`, and `Routes` in favor of a more generic approach. Use the new `Inject` extractor to access dependencies in your Axum handlers.\\n- `nakago-warp` - Removed `WarpApplication`, `Route`, and `Routes` in favor of a more generic approach. Use the `with_injection()` Filter to access dependencies in your Warp handlers.\\n\\n### Changed\\n\\n- `nakago` - The tag-based container operations were previously the default mode of working with `Inject`. This proved to be more verbose and than necessary in most cases, however. The new default mode is to use the type-based operations, which are more ergonomic and easier to use. The tag-based operations are still available, but they are now suffixed with `_tag` to make it clear that they are a different mode of operation. The type-based operations are no longer suffixed with `_type`, because they are now the default.\\n- `nakago` - The `inject` namespace has been promoted to the top level. Where `nakago::inject` was used before, `nakago` should now be the equivalent.\\n- `nakago` - The `config` utilities were moved to `nakago-figment`.\\n- `nakago-examples-simple`, `nakago-examples-async-graphql`, `nakago-examples-simple-warp` - Updated with the new approach. See these examples for more information about how to use the tools mentioned above.\\n\\n### Added\\n\\n- `nakago-axum` - Added a new `Inject` extractor to access dependencies in your Axum handlers. This is a much more idiomatic way to use Nakago with Axum, and it\'s more flexible than the previous approach. Use the provided Axum `State` to make the `Inject` container available to your handlers.\\n- `nakago-figment` - Generic config utilities extracted from the core `nakago` package."},{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/bkonkle/nakago/tree/main/website/blog/2023-08-30-welcome.md","source":"@site/blog/2023-08-30-welcome.md","title":"Welcome","description":"Welcome to Nakago","date":"2023-08-30T00:00:00.000Z","tags":[],"readingTime":0.825,"hasTruncateMarker":false,"authors":[{"name":"Brandon Konkle","title":"Principal Engineer @ Formidable","url":"https://github.com/bkonkle","imageURL":"https://github.com/bkonkle.png","key":"bkonkle","page":null}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["bkonkle"]},"unlisted":false,"prevItem":{"title":"Pivot to a Dependency Injection Toolkit","permalink":"/blog/pivot-di-toolkit"}},"content":"## Welcome to Nakago\\n\\nI created Nakago to help organize my Rust projects and cut down on boilerplate code as my applications grew larger. I wanted a framework that would allow me to focus on the business logic of my applications, while providing a solid foundation for the rest of the code.\\n\\nI\'ve had great experiences in other language ecosystems with frameworks like Django in Python and Nest.js in TypeScript. I wanted to bring some of the same ideas to Rust, while taking advantage of the unique features of the language.\\n\\nNakago is a lightweight framework for building Rust applications with a modular structure, taking advantage of dependency injection and lifecycle events to bring organization and testability to Rust projects large and small.\\n\\n### Documentation & Examples\\n\\nCheck out the [Documentation](/docs/intro) and [Examples](/docs/examples) to learn more about how to use Nakago. A 10-minute tutorial is coming soon, and stay tuned for videos on YouTube and Twitch as I begin to share my experiences with Nakago."}]}}')}}]);