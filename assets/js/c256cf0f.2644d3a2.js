"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[176],{6737:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>r,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var t=n(4848),i=n(8453);const a={slug:"pivot-di-toolkit",title:"Pivot to a Dependency Injection Toolkit",authors:["bkonkle"]},d=void 0,s={permalink:"/blog/pivot-di-toolkit",editUrl:"https://github.com/bkonkle/nakago/tree/main/website/blog/2024-08-28-pivot.md",source:"@site/blog/2024-08-28-pivot.md",title:"Pivot to a Dependency Injection Toolkit",description:"Nakago Pivots to a Dependency Injection Toolkit",date:"2024-08-28T00:00:00.000Z",tags:[],readingTime:2.42,hasTruncateMarker:!1,authors:[{name:"Brandon Konkle",title:"Principal Engineer @ Formidable",url:"https://github.com/bkonkle",imageURL:"https://github.com/bkonkle.png",key:"bkonkle",page:null}],frontMatter:{slug:"pivot-di-toolkit",title:"Pivot to a Dependency Injection Toolkit",authors:["bkonkle"]},unlisted:!1,nextItem:{title:"Welcome",permalink:"/blog/welcome"}},r={authorsImageUrls:[void 0]},c=[{value:"Nakago Pivots to a Dependency Injection Toolkit",id:"nakago-pivots-to-a-dependency-injection-toolkit",level:2},{value:"The v0.23 Changelog",id:"the-v023-changelog",level:3},{value:"Removed",id:"removed",level:3},{value:"Changed",id:"changed",level:3},{value:"Added",id:"added",level:3}];function l(e){const o={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(o.h2,{id:"nakago-pivots-to-a-dependency-injection-toolkit",children:"Nakago Pivots to a Dependency Injection Toolkit"}),"\n",(0,t.jsxs)(o.p,{children:["With the release of Nakago v0.23, the project is pivoting away from the ambitious goal of a full-featured API framework, and towards a more streamlined dependency injection toolkit instead. The async Rust ecosystem is growing rapidly, and I haven't been able to devote enough time to Nakago to grow the application lifecycle and convenience features that I had originally envisioned. There are other projects that are doing a great job of providing these features - like ",(0,t.jsx)(o.a,{href:"https://loco.rs/",children:"Loco"}),", ",(0,t.jsx)(o.a,{href:"https://github.com/http-rs/tide",children:"Tide"}),", ",(0,t.jsx)(o.a,{href:"https://github.com/SeaQL/seaography",children:"Seaography"}),", or ",(0,t.jsx)(o.a,{href:"https://salvo.rs/",children:"Salvo"}),"."]}),"\n",(0,t.jsxs)(o.p,{children:["What I haven't seen yet, however, is an async-first dependency injection container that is as lightweight and easy to work with as Nakago is, and doesn't require a lot of opaque macros or code generation. Nakago uses macros sparingly and takes advantage of Rust's ",(0,t.jsx)(o.code,{children:"Any"})," dynamic typing tools to support a thread-safe, async-first dependency injection container that would work well with a variety of different Rust frameworks and team sizes."]}),"\n",(0,t.jsx)(o.p,{children:"I'll continue refining Nakago and adding features and integrations as I have need of them on side projects, and I'd love to collaborate with others who are interested in building a lightweight, async-first dependency injection toolkit for Rust."}),"\n",(0,t.jsx)(o.h3,{id:"the-v023-changelog",children:"The v0.23 Changelog"}),"\n",(0,t.jsx)(o.h3,{id:"removed",children:"Removed"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago"})," - Removed ",(0,t.jsx)(o.code,{children:"Application"}),", ",(0,t.jsx)(o.code,{children:"Hooks"}),", the ",(0,t.jsx)(o.code,{children:"lifecycle::EventType"})," and ",(0,t.jsx)(o.code,{children:"lifecycle::Events"})," enums. The ",(0,t.jsx)(o.code,{children:"config"})," utilities were moved to ",(0,t.jsx)(o.code,{children:"nakago-figment"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago-axum"})," - Removed ",(0,t.jsx)(o.code,{children:"AxumApplication"}),", ",(0,t.jsx)(o.code,{children:"Route"}),", and ",(0,t.jsx)(o.code,{children:"Routes"})," in favor of a more generic approach. Use the new ",(0,t.jsx)(o.code,{children:"Inject"})," extractor to access dependencies in your Axum handlers."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago-warp"})," - Removed ",(0,t.jsx)(o.code,{children:"WarpApplication"}),", ",(0,t.jsx)(o.code,{children:"Route"}),", and ",(0,t.jsx)(o.code,{children:"Routes"})," in favor of a more generic approach. Use the ",(0,t.jsx)(o.code,{children:"with_injection()"})," Filter to access dependencies in your Warp handlers."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"changed",children:"Changed"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago"})," - The tag-based container operations were previously the default mode of working with ",(0,t.jsx)(o.code,{children:"Inject"}),". This proved to be more verbose and than necessary in most cases, however. The new default mode is to use the type-based operations, which are more ergonomic and easier to use. The tag-based operations are still available, but they are now suffixed with ",(0,t.jsx)(o.code,{children:"_tag"})," to make it clear that they are a different mode of operation. The type-based operations are no longer suffixed with ",(0,t.jsx)(o.code,{children:"_type"}),", because they are now the default."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago"})," - The ",(0,t.jsx)(o.code,{children:"inject"})," namespace has been promoted to the top level. Where ",(0,t.jsx)(o.code,{children:"nakago::inject"})," was used before, ",(0,t.jsx)(o.code,{children:"nakago"})," should now be the equivalent."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago"})," - The ",(0,t.jsx)(o.code,{children:"config"})," utilities were moved to ",(0,t.jsx)(o.code,{children:"nakago-figment"}),"."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago-examples-simple"}),", ",(0,t.jsx)(o.code,{children:"nakago-examples-async-graphql"}),", ",(0,t.jsx)(o.code,{children:"nakago-examples-simple-warp"})," - Updated with the new approach. See these examples for more information about how to use the tools mentioned above."]}),"\n"]}),"\n",(0,t.jsx)(o.h3,{id:"added",children:"Added"}),"\n",(0,t.jsxs)(o.ul,{children:["\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago-axum"})," - Added a new ",(0,t.jsx)(o.code,{children:"Inject"})," extractor to access dependencies in your Axum handlers. This is a much more idiomatic way to use Nakago with Axum, and it's more flexible than the previous approach. Use the provided Axum ",(0,t.jsx)(o.code,{children:"State"})," to make the ",(0,t.jsx)(o.code,{children:"Inject"})," container available to your handlers."]}),"\n",(0,t.jsxs)(o.li,{children:[(0,t.jsx)(o.code,{children:"nakago-figment"})," - Generic config utilities extracted from the core ",(0,t.jsx)(o.code,{children:"nakago"})," package."]}),"\n"]})]})}function h(e={}){const{wrapper:o}={...(0,i.R)(),...e.components};return o?(0,t.jsx)(o,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,o,n)=>{n.d(o,{R:()=>d,x:()=>s});var t=n(6540);const i={},a=t.createContext(i);function d(e){const o=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function s(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(a.Provider,{value:o},e.children)}}}]);