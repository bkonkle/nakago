"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[108],{359:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>c});var a=t(5893),i=t(1151);const s={sidebar_position:5},r="Async-GraphQL",o={id:"features/async-graphql",title:"Async-GraphQL",description:"The GraphQL integration is built around a flexible Schema Builder approach that allows you to modify the in-progress schema to incrementally add things like DataLoaders and other context for your Resolvers. It uses the Init lifecycle hook as a trigger to build the final schema, making it available to the rest of your application through type ID or Tag.",source:"@site/docs/features/async-graphql.md",sourceDirName:"features",slug:"/features/async-graphql",permalink:"/docs/features/async-graphql",draft:!1,unlisted:!1,editUrl:"https://github.com/bkonkle/nakago/tree/main/website/docs/features/async-graphql.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"documentationSidebar",previous:{title:"SeaORM",permalink:"/docs/features/sea-orm"},next:{title:"Examples",permalink:"/docs/examples"}},l={},c=[{value:"Dependencies vs. Context",id:"dependencies-vs-context",level:2},{value:"Resolvers",id:"resolvers",level:2},{value:"Loading",id:"loading",level:2},{value:"Initialization",id:"initialization",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"async-graphql",children:"Async-GraphQL"}),"\n",(0,a.jsx)(n.p,{children:"The GraphQL integration is built around a flexible Schema Builder approach that allows you to modify the in-progress schema to incrementally add things like DataLoaders and other context for your Resolvers. It uses the Init lifecycle hook as a trigger to build the final schema, making it available to the rest of your application through type ID or Tag."}),"\n",(0,a.jsx)(n.h2,{id:"dependencies-vs-context",children:"Dependencies vs. Context"}),"\n",(0,a.jsx)(n.p,{children:'Async-GraphQL provides its own lightweight synchronous dependency injection system within their request Context, called "data". In typical Async-GraphQL applications, this is used similarly to Axum State to provide dependencies that each Resolver needs to do its job.'}),"\n",(0,a.jsx)(n.p,{children:"As we do with the Axum integration, for Nakago apps we separate the concept of Dependencies from the concept of Context, and instead use the Inject container to provide dependencies that remain the same across all requests. Data that varies from request to request should still be carried through the Context data, as usual."}),"\n",(0,a.jsx)(n.h2,{id:"resolvers",children:"Resolvers"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"/// The Query segment for Users\n#[derive(Default)]\npub struct UsersQuery {}\n\n/// Queries for the User model\n#[Object]\nimpl UsersQuery {\n    /// Get the current User from the GraphQL context\n    async fn get_current_user(&self, ctx: &Context<'_>) -> Result<Option<User>> {\n        let user = ctx.data_unchecked::<Option<User>>();\n\n        Ok(user.clone())\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"loading",children:"Loading"}),"\n",(0,a.jsx)(n.p,{children:"One strategy to keep things encapsulated is to use a domain-specific Load lifecycle hook to inject all of the Providers that are specific to a particular entity or area of concern - like Users or Profiles or other application-specific focuses."}),"\n",(0,a.jsx)(n.p,{children:"For example, a Load hook for a Users domain might want to provide a Service and a DataLoader along with a Query and a Mutation that will use them, all focused on Users:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use super::{\n    loaders::{self, LOADER},\n    mutation, query,\n    service::{self, SERVICE},\n    MUTATION, QUERY,\n};\n\n#[derive(Default)]\npub struct Load {}\n\n#[async_trait]\nimpl Hook for Load {\n    async fn handle(&self, i: Inject) -> inject::Result<()> {\n        i.provide(&SERVICE, service::Provide::default()).await?;\n        i.provide(&LOADER, loaders::Provide::default()).await?;\n        i.provide(&QUERY, query::Provide::default()).await?;\n        i.provide(&MUTATION, mutation::Provide::default()).await?;\n\n        Ok(())\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["To collect all of the dependencies needed for a particular application, you might have a top-level ",(0,a.jsx)(n.code,{children:"graphql.rs"})," module that contains an Init hook that simply composes together the smaller individual Init hooks for each domain:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"use super::{episodes, profiles, role_grants, shows, users};\n\n#[derive(Default)]\npub struct Load {}\n\n#[async_trait]\nimpl Hook for Load {\n    async fn handle(&self, i: Inject) -> inject::Result<()> {\n        i.handle(users::schema::Load::default()).await?;\n        i.handle(profiles::schema::Load::default()).await?;\n        i.handle(role_grants::schema::Load::default()).await?;\n        i.handle(shows::schema::Load::default()).await?;\n        i.handle(episodes::schema::Load::default()).await?;\n\n        Ok(())\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In your application's top-level ",(0,a.jsx)(n.code,{children:"init.rs"})," file, you could then simply add this top-level GraphQL Load hook to the list of hooks that are run in response to the Load lifecycle event:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub async fn app() -> inject::Result<AxumApplication<Config>> {\n    let mut app = AxumApplication::default().with_config_tag(&CONFIG);\n\n    // ...\n\n    app.on(&EventType::Load, graphql::Load::default());\n\n    // ...\n\n    Ok(app)\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"initialization",children:"Initialization"}),"\n",(0,a.jsx)(n.p,{children:"In the Init phase, you can provide a top-level SchemaBuilder that other modules can optionally extend, culminating in a fully operation schema ready to execute GraphQL operations."}),"\n",(0,a.jsxs)(n.p,{children:["First, build your schema using the standard ",(0,a.jsx)(n.code,{children:"async_graphql"})," approach, building MergedObjects for your top-level Query and Mutation types:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"/// The GraphQL top-level Query type\n#[derive(MergedObject)]\npub struct Query(users::Query, profiles::Query);\n\n/// The GraphQL top-level Mutation type\n#[derive(MergedObject)]\npub struct Mutation(\n    users::Mutation,\n    profiles::Mutation,\n);\n\n/// The application's top-level merged GraphQL schema\npub type Schema = async_graphql::Schema<Query, Mutation, EmptySubscription>;\n\n/// The application's top-level GraphQL schema builder\npub type SchemaBuilder = async_graphql::SchemaBuilder<Query, Mutation, EmptySubscription>;\n"})}),"\n",(0,a.jsx)(n.p,{children:"Then, provide tags to represent each type in the Inject container:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:'/// Tag(graphql::Schema)\npub const SCHEMA: Tag<Schema> = Tag::new("graphql::Schema");\n\n/// Tag(graphql::SchemaBuilder)\npub const SCHEMA_BUILDER: Tag<SchemaBuilder> = Tag::new("graphql::SchemaBuilder");\n'})}),"\n",(0,a.jsx)(n.p,{children:"Finally, define an Init hook that constructs your top-level SchemaBuilder and injects it to the container so that it will be available for any Init hooks that want to add context:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"#[derive(Default)]\npub struct Init {}\n\n#[async_trait]\nimpl Hook for Init {\n    async fn handle(&self, i: Inject) -> inject::Result<()> {\n        let users_query = i.consume(&users::QUERY).await?;\n        let profiles_query = i.consume(&profiles::QUERY).await?;\n\n        let users_mutation = i.consume(&users::MUTATION).await?;\n        let profiles_mutation = i.consume(&profiles::MUTATION).await?;\n\n        let builder = Schema::build(\n            Query(users_query, profiles_query),\n            Mutation(users_mutation, profiles_mutation),\n            EmptySubscription,\n        );\n\n        i.inject(&SCHEMA_BUILDER, builder).await?;\n\n        i.handle(users::schema::Init::default()).await?;\n        i.handle(profiles::schema::Init::default()).await?;\n\n        i.handle(\n            schema::Init::default()\n                .with_builder_tag(&SCHEMA_BUILDER)\n                .with_schema_tag(&SCHEMA),\n        )\n        .await?;\n\n        Ok(())\n    }\n}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["In your application's top-level ",(0,a.jsx)(n.code,{children:"init.rs"})," file, you can then add this top-level GraphQL Init hook to the list of hooks that are run in response to the Init lifecycle event:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-rust",children:"pub async fn app() -> inject::Result<AxumApplication<Config>> {\n    let mut app = AxumApplication::default().with_config_tag(&CONFIG);\n\n    // ...\n\n    app.on(&EventType::Init, graphql::Init::default());\n\n    // ...\n\n    Ok(app)\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>o,a:()=>r});var a=t(7294);const i={},s=a.createContext(i);function r(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);