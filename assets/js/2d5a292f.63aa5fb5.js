"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[187],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),h=r,m=c["".concat(l,".").concat(h)]||c[h]||d[h]||o;return n?a.createElement(m,i(i({ref:t},u),{},{components:n})):a.createElement(m,i({ref:t},u))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},2684:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const o={sidebar_position:3},i="Axum HTTP Applications",s={unversionedId:"features/axum-http",id:"features/axum-http",title:"Axum HTTP Applications",description:"The nakago-axum crate defines AxumApplication, which wraps Application and provides a way to Run an HTTP service and use the Inject container via Axum's State mechanism.",source:"@site/docs/features/axum-http.md",sourceDirName:"features",slug:"/features/axum-http",permalink:"/docs/features/axum-http",draft:!1,editUrl:"https://github.com/bkonkle/nakago/tree/main/website/docs/features/axum-http.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"documentationSidebar",previous:{title:"Application Lifecycle",permalink:"/docs/features/application"},next:{title:"SeaORM",permalink:"/docs/features/sea-orm"}},l={},p=[{value:"Dependencies vs. Context",id:"dependencies-vs-context",level:2},{value:"Application Lifecycle",id:"application-lifecycle",level:2},{value:"Init",id:"init",level:3},{value:"Startup",id:"startup",level:3},{value:"Routes",id:"routes",level:2},{value:"Controllers",id:"controllers",level:3},{value:"Functional Handlers",id:"functional-handlers",level:3},{value:"Starting the Application",id:"starting-the-application",level:2},{value:"Integration Testing",id:"integration-testing",level:2},{value:"CI Integration Testing",id:"ci-integration-testing",level:3}],u={toc:p},c="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"axum-http-applications"},"Axum HTTP Applications"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"nakago-axum")," crate defines ",(0,r.kt)("inlineCode",{parentName:"p"},"AxumApplication"),", which wraps ",(0,r.kt)("inlineCode",{parentName:"p"},"Application")," and provides a way to Run an HTTP service and use the ",(0,r.kt)("inlineCode",{parentName:"p"},"Inject")," container via Axum's ",(0,r.kt)("inlineCode",{parentName:"p"},"State")," mechanism."),(0,r.kt)("h2",{id:"dependencies-vs-context"},"Dependencies vs. Context"),(0,r.kt)("p",null,"Axum provides the State extractor that allows you to inject dependencies that stay the same across many requests. For Nakago applications, however, your dependencies are provided through the Inject container. Nakago Axum apps use State to automatically carry the Inject container, but in a way that you don't have to think about while building typicaly applications."),(0,r.kt)("h2",{id:"application-lifecycle"},"Application Lifecycle"),(0,r.kt)("h3",{id:"init"},"Init"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Init")," Hook for an Axum Application automatically adds the ",(0,r.kt)("inlineCode",{parentName:"p"},"http::Config")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"auth::Config")," Loaders before the user-provided hook is invoked and the Config is generated."),(0,r.kt)("h3",{id:"startup"},"Startup"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Startup")," Hook for an Axum Application uses the State with the provided Router, allowing the flow of the application to proceed through the Axum request handlers."),(0,r.kt)("h2",{id:"routes"},"Routes"),(0,r.kt)("p",null,"Routes are initialized on Init. There are multiple options for how to implement handlers and access their Dependencies. The approach with the smoothest Nakago integration also has the benefit of allowing you to define Controller structs with methods that can be used as handlers, allowing you to share common dependencies between related Axum request handlers."),(0,r.kt)("h3",{id:"controllers"},"Controllers"),(0,r.kt)("p",null,"Start with a hypothetical Controller for a WebSocket connection, that will handle requests to upgrade an HTTP request to a WebSocket connection:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub const CONTROLLER: Tag<Controller> = Tag::new("events::Controller");\n\n#[derive(Clone)]\npub struct Controller {\n    users: Arc<Box<dyn users::Service>>,\n    handler: Arc<socket::Handler>,\n}\n')),(0,r.kt)("p",null,'It has a dependency on the Users Service and the Socket Handler, which are both used within the "upgrade()" method:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"impl Controller {\n    /// Create a new Events handler\n    pub async fn upgrade(\n        self: Arc<Self>,\n        sub: Subject,\n        ws: WebSocketUpgrade,\n    ) -> axum::response::Result<impl IntoResponse> {\n        // Retrieve the request User, if username is present\n        let user = if let Subject(Some(ref username)) = sub {\n            self.users\n                .get_by_username(username, &true)\n                .await\n                .unwrap_or(None)\n        } else {\n            None\n        };\n\n        Ok(ws.on_upgrade(|socket| async move { self.handler.handle(socket, user).await }))\n    }\n}\n")),(0,r.kt)("p",null,"As you can see, standard Axum extractors like ",(0,r.kt)("inlineCode",{parentName:"p"},"Subject")," are usable within the Controller methods, and the Controller can use ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," to access Dependencies and complete the work it needs to do. Other methods can be added that share the same dependencies, organized around a common business domain or other focus."),(0,r.kt)("p",null,"Couple this with a Provider that can be used to inject the dependency:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"#[derive(Default)]\npub struct Provide {}\n\n#[Provider]\n#[async_trait]\nimpl Provider<Controller> for Provide {\n    async fn provide(self: Arc<Self>, i: Inject) -> inject::Result<Arc<Controller>> {\n        let users = i.get(&users::SERVICE).await?;\n        let handler = i.get(&socket::HANDLER).await?;\n\n        Ok(Arc::new(Controller { users, handler }))\n    }\n}\n")),(0,r.kt)("p",null,"The route can then be initialized with an Init hook:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Default)]\npub struct Init {}\n\n#[async_trait]\nimpl Hook for Init {\n    async fn handle(&self, i: Inject) -> inject::Result<()> {\n        let events_controller = i.get(&events::CONTROLLER).await?;\n\n        i.handle(routes::Init::new(\n            Method::GET,\n            "/events",\n            move |sub, ws| async move {\n                events::Controller::upgrade(events_controller, sub, ws).await\n            },\n        ))\n        .await?;\n\n        Ok(())\n    }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"move |sub, ws| async move {}")," function is a necessary shim to wrap the method to use it as a handler."),(0,r.kt)("h3",{id:"functional-handlers"},"Functional Handlers"),(0,r.kt)("p",null,"Functional handlers eschew the typical Nakago approach of using a struct with Dependencies on the ",(0,r.kt)("inlineCode",{parentName:"p"},"self")," instance, and instead use async functions with access to an Axum State extractor that pulls the ",(0,r.kt)("inlineCode",{parentName:"p"},"Inject")," container out of the State."),(0,r.kt)("p",null,"Here's an example of a route handler implemented as an async function that uses the Inject container to retrieve a Users Service and a WebSocket connection handler::"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use nakago_axum::{auth::Subject, Error, Inject};\n\npub async fn upgrade(\n    Inject(i): Inject,\n    sub: Subject,\n    ws: WebSocketUpgrade,\n) -> axum::response::Result<impl IntoResponse> {\n    let users = i.get(&users::SERVICE).await.map_err(Error)?;\n    let handler = i.get(&socket::HANDLER).await.map_err(Error)?;\n\n    // Retrieve the request User, if username is present\n    let user = if let Subject(Some(ref username)) = sub {\n        users.get_by_username(username, &true).await.unwrap_or(None)\n    } else {\n        None\n    };\n\n    Ok(ws.on_upgrade(|socket| async move { handler.handle(socket, user).await }))\n}\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"Inject")," extractor from the ",(0,r.kt)("inlineCode",{parentName:"p"},"nakago_axum")," package is used to retrieve the ",(0,r.kt)("inlineCode",{parentName:"p"},"Inject")," container from the State. This container is then used to retrieve the ",(0,r.kt)("inlineCode",{parentName:"p"},"users::SERVICE")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"socket::HANDLER")," services from the container, mapping the errors to the special ",(0,r.kt)("inlineCode",{parentName:"p"},"nakago_axum:Error")," wrapper that works as an Axum response."),(0,r.kt)("p",null,"Then you can initialize the route in an Init hook:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'#[derive(Default)]\npub struct Init {}\n\n#[async_trait]\nimpl Hook for Init {\n    async fn handle(&self, _i: Inject) -> inject::Result<()> {\n        i.handle(routes::Init::new(\n            Method::GET,\n            "/events",\n            events::upgrade,\n        ))\n        .await?;\n\n        Ok(())\n    }\n}\n')),(0,r.kt)("h2",{id:"starting-the-application"},"Starting the Application"),(0,r.kt)("p",null,"To start your application, pass in your top-level Config type and create an instance. Attach Hooks in the order that they should be executed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let mut app = AxumApplication::<Config>::default();\napp.on(&EventType::Load, authz::Load::default());\napp.on(&EventType::Load, graphql::Load::default());\napp.on(&EventType::Init, graphql::Init::default());\n")),(0,r.kt)("p",null,"Then, use ",(0,r.kt)("inlineCode",{parentName:"p"},"run")," to start the application and return the connection details."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let server = app.run(args.config_path).await?;\nlet addr = server.local_addr();\n\ninfo!("Started on port: {port}", port = addr.port());\n\nserver.await?;\n')),(0,r.kt)("h2",{id:"integration-testing"},"Integration Testing"),(0,r.kt)("p",null,"Testing is handled by initializing your application server in a way similar to Production, and using a Lazy OnceCell to hold an HttpConnector you can use to make requests to the application."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"static HTTP_CLIENT: Lazy<Client<HttpsConnector<HttpConnector>>> = Lazy::new(http_client);\n\n/// Creates an http/https client via Hyper\npub fn http_client() -> Client<HttpsConnector<HttpConnector>> {\n    Client::builder().build::<_, Body>(HttpsConnector::new())\n}\n")),(0,r.kt)("p",null,"This can then be used to make requests to the running application instance for integration testing:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"let mut req = Request::builder().method(Method::POST).uri(&self.url);\n\nlet resp = http_client.request(req).await?;\n")),(0,r.kt)("p",null,"See the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/bkonkle/nakago/tree/feature/nakago-sea-orm/examples/async-graphql/tests"},"Async-GraphQL Example's integration tests")," for examples of how to use this pattern. This will evolve as more pieces are moved into the framework itself over time."),(0,r.kt)("h3",{id:"ci-integration-testing"},"CI Integration Testing"),(0,r.kt)("p",null,"This strategy can be used for integration testing in the CI service of your choice based on a Docker Compose formation of shallow dependencies. This allows you to set up things like LocalStack or Postgers within your CI Docker environment and run integration tests against them without needing to use deployed resources. Branch-specific PR's are easy to run tests for in isolation."),(0,r.kt)("p",null,"Stay tuned for more details on how to set up this approach in your CI environment."))}d.isMDXComponent=!0}}]);