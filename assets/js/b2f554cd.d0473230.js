"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"welcome","metadata":{"permalink":"/blog/welcome","editUrl":"https://github.com/bkonkle/nakago/tree/main/website/blog/2023-08-30-welcome.md","source":"@site/blog/2023-08-30-welcome.md","title":"Welcome","description":"Welcome to Nakago","date":"2023-08-30T00:00:00.000Z","formattedDate":"August 30, 2023","tags":[],"readingTime":0.825,"hasTruncateMarker":false,"authors":[{"name":"Brandon Konkle","title":"Principal Engineer @ Formidable","url":"https://github.com/bkonkle","imageURL":"https://github.com/bkonkle.png","key":"bkonkle"}],"frontMatter":{"slug":"welcome","title":"Welcome","authors":["bkonkle"]},"unlisted":false},"content":"## Welcome to Nakago\\n\\nI created Nakago to help organize my Rust projects and cut down on boilerplate code as my applications grew larger. I wanted a framework that would allow me to focus on the business logic of my applications, while providing a solid foundation for the rest of the code.\\n\\nI\'ve had great experiences in other language ecosystems with frameworks like Django in Python and Nest.js in TypeScript. I wanted to bring some of the same ideas to Rust, while taking advantage of the unique features of the language.\\n\\nNakago is a lightweight framework for building Rust applications with a modular structure, taking advantage of dependency injection and lifecycle events to bring organization and testability to Rust projects large and small.\\n\\n### Documentation & Examples\\n\\nCheck out the [Documentation](/docs/intro) and [Examples](/docs/examples) to learn more about how to use Nakago. A 10-minute tutorial is coming soon, and stay tuned for videos on YouTube and Twitch as I begin to share my experiences with Nakago."}]}')}}]);