"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[176],{6737:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>d,toc:()=>c});var t=o(4848),a=o(8453);const i={slug:"welcome",title:"Welcome",authors:["bkonkle"]},s=void 0,d={permalink:"/blog/welcome",editUrl:"https://github.com/bkonkle/nakago/tree/main/website/blog/2024-08-28-pivot.md",source:"@site/blog/2024-08-28-pivot.md",title:"Welcome",description:"Nakago Pivots to a Dependency Injection Toolkit",date:"2024-08-28T00:00:00.000Z",tags:[],readingTime:2.42,hasTruncateMarker:!1,authors:[{name:"Brandon Konkle",title:"Principal Engineer @ Formidable",url:"https://github.com/bkonkle",imageURL:"https://github.com/bkonkle.png",key:"bkonkle",page:null}],frontMatter:{slug:"welcome",title:"Welcome",authors:["bkonkle"]},unlisted:!1,nextItem:{title:"Welcome",permalink:"/blog/welcome"}},r={authorsImageUrls:[void 0]},c=[{value:"Nakago Pivots to a Dependency Injection Toolkit",id:"nakago-pivots-to-a-dependency-injection-toolkit",level:2},{value:"The v0.23 Changelog",id:"the-v023-changelog",level:3},{value:"Removed",id:"removed",level:3},{value:"Changed",id:"changed",level:3},{value:"Added",id:"added",level:3}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"nakago-pivots-to-a-dependency-injection-toolkit",children:"Nakago Pivots to a Dependency Injection Toolkit"}),"\n",(0,t.jsxs)(n.p,{children:["With the release of Nakago v0.23, the project is pivoting away from the ambitious goal of a full-featured API framework, and towards a more streamlined dependency injection toolkit instead. The async Rust ecosystem is growing rapidly, and I haven't been able to devote enough time to Nakago to grow the application lifecycle and convenience features that I had originally envisioned. There are other projects that are doing a great job of providing these features - like ",(0,t.jsx)(n.a,{href:"https://loco.rs/",children:"Loco"}),", ",(0,t.jsx)(n.a,{href:"https://github.com/http-rs/tide",children:"Tide"}),", ",(0,t.jsx)(n.a,{href:"https://github.com/SeaQL/seaography",children:"Seaography"}),", or ",(0,t.jsx)(n.a,{href:"https://salvo.rs/",children:"Salvo"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["What I haven't seen yet, however, is an async-first dependency injection container that is as lightweight and easy to work with as Nakago is, and doesn't require a lot of opaque macros or code generation. Nakago uses macros sparingly and takes advantage of Rust's ",(0,t.jsx)(n.code,{children:"Any"})," dynamic typing tools to support a thread-safe, async-first dependency injection container that would work well with a variety of different Rust frameworks and team sizes."]}),"\n",(0,t.jsx)(n.p,{children:"I'll continue refining Nakago and adding features and integrations as I have need of them on side projects, and I'd love to collaborate with others who are interested in building a lightweight, async-first dependency injection toolkit for Rust."}),"\n",(0,t.jsx)(n.h3,{id:"the-v023-changelog",children:"The v0.23 Changelog"}),"\n",(0,t.jsx)(n.h3,{id:"removed",children:"Removed"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago"})," - Removed ",(0,t.jsx)(n.code,{children:"Application"}),", ",(0,t.jsx)(n.code,{children:"Hooks"}),", the ",(0,t.jsx)(n.code,{children:"lifecycle::EventType"})," and ",(0,t.jsx)(n.code,{children:"lifecycle::Events"})," enums. The ",(0,t.jsx)(n.code,{children:"config"})," utilities were moved to ",(0,t.jsx)(n.code,{children:"nakago-figment"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago-axum"})," - Removed ",(0,t.jsx)(n.code,{children:"AxumApplication"}),", ",(0,t.jsx)(n.code,{children:"Route"}),", and ",(0,t.jsx)(n.code,{children:"Routes"})," in favor of a more generic approach. Use the new ",(0,t.jsx)(n.code,{children:"Inject"})," extractor to access dependencies in your Axum handlers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago-warp"})," - Removed ",(0,t.jsx)(n.code,{children:"WarpApplication"}),", ",(0,t.jsx)(n.code,{children:"Route"}),", and ",(0,t.jsx)(n.code,{children:"Routes"})," in favor of a more generic approach. Use the ",(0,t.jsx)(n.code,{children:"with_injection()"})," Filter to access dependencies in your Warp handlers."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"changed",children:"Changed"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago"})," - The tag-based container operations were previously the default mode of working with ",(0,t.jsx)(n.code,{children:"Inject"}),". This proved to be more verbose and than necessary in most cases, however. The new default mode is to use the type-based operations, which are more ergonomic and easier to use. The tag-based operations are still available, but they are now suffixed with ",(0,t.jsx)(n.code,{children:"_tag"})," to make it clear that they are a different mode of operation. The type-based operations are no longer suffixed with ",(0,t.jsx)(n.code,{children:"_type"}),", because they are now the default."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago"})," - The ",(0,t.jsx)(n.code,{children:"inject"})," namespace has been promoted to the top level. Where ",(0,t.jsx)(n.code,{children:"nakago::inject"})," was used before, ",(0,t.jsx)(n.code,{children:"nakago"})," should now be the equivalent."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago"})," - The ",(0,t.jsx)(n.code,{children:"config"})," utilities were moved to ",(0,t.jsx)(n.code,{children:"nakago-figment"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago-examples-simple"}),", ",(0,t.jsx)(n.code,{children:"nakago-examples-async-graphql"}),", ",(0,t.jsx)(n.code,{children:"nakago-examples-simple-warp"})," - Updated with the new approach. See these examples for more information about how to use the tools mentioned above."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"added",children:"Added"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago-axum"})," - Added a new ",(0,t.jsx)(n.code,{children:"Inject"})," extractor to access dependencies in your Axum handlers. This is a much more idiomatic way to use Nakago with Axum, and it's more flexible than the previous approach. Use the provided Axum ",(0,t.jsx)(n.code,{children:"State"})," to make the ",(0,t.jsx)(n.code,{children:"Inject"})," container available to your handlers."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"nakago-figment"})," - Generic config utilities extracted from the core ",(0,t.jsx)(n.code,{children:"nakago"})," package."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>d});var t=o(6540);const a={},i=t.createContext(a);function s(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);