"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[849],{6164:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"documentationSidebar":[{"type":"link","label":"Welcome to Nakago","href":"/docs/intro","docId":"intro","unlisted":false},{"type":"link","label":"Tutorial","href":"/docs/tutorial","docId":"tutorial","unlisted":false},{"type":"category","label":"Features","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Dependency Injection","href":"/docs/features/dependency-injection","docId":"features/dependency-injection","unlisted":false},{"type":"link","label":"Using Nakago with Axum","href":"/docs/features/axum-http","docId":"features/axum-http","unlisted":false},{"type":"link","label":"SeaORM","href":"/docs/features/sea-orm","docId":"features/sea-orm","unlisted":false},{"type":"link","label":"Async-GraphQL","href":"/docs/features/async-graphql","docId":"features/async-graphql","unlisted":false}],"href":"/docs/category/features"},{"type":"link","label":"Examples","href":"/docs/examples","docId":"examples","unlisted":false},{"type":"link","label":"Development","href":"/docs/development","docId":"development","unlisted":false}]},"docs":{"development":{"id":"development","title":"Development","description":"To set up a development environment to build this project, you\'ll need to install some helpful tools.","sidebar":"documentationSidebar"},"examples":{"id":"examples","title":"Examples","description":"Simple","sidebar":"documentationSidebar"},"features/async-graphql":{"id":"features/async-graphql","title":"Async-GraphQL","description":"The GraphQL integration is built around a flexible Schema Builder approach that allows you to modify the in-progress schema to incrementally add things like DataLoaders and other context for your Resolvers. It uses an init function as a trigger to build the final schema, making it available to the rest of your application through type ID or Tag.","sidebar":"documentationSidebar"},"features/axum-http":{"id":"features/axum-http","title":"Using Nakago with Axum","description":"The nakago-axum crate defines provides a way to easily use the Nakago Inject container via Axum\'s State mechanism.","sidebar":"documentationSidebar"},"features/dependency-injection":{"id":"features/dependency-injection","title":"Dependency Injection","description":"Dependency injection is a way to decouple your structures from their dependencies. It allows you to replace the components that your system needs with alternative implementations for different situations.","sidebar":"documentationSidebar"},"features/sea-orm":{"id":"features/sea-orm","title":"SeaORM","description":"(Documentation coming soon...)","sidebar":"documentationSidebar"},"intro":{"id":"intro","title":"Welcome to Nakago","description":"Nakago is a toolkit for building Rust applications with a modular structure, taking advantage of dependency injection to bring organization and testability to Rust projects large and small.","sidebar":"documentationSidebar"},"tutorial":{"id":"tutorial","title":"Tutorial","description":"This tutorial will walk you through the basics of using Nakago to build a simple HTTP service. It will use Axum to provide HTTP routes and will decode the user\'s JWT token and verify their identity via a separate OAuth2 provider, such as Auth0 or Okta or your own self-hosted service.","sidebar":"documentationSidebar"}}}}')}}]);